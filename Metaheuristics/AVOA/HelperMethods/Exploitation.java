package Metaheuristics.AVOA.HelperMethods;

import java.util.Random;

import static Metaheuristics.AVOA.HelperMethods.LevyFlight.levyFlight;

public class Exploitation {
    /**
     * Updates the current vulture position based on exploitation.
     *
     * @param current_vulture_X  The current vulture position array to be updated.
     * @param Best_vulture1_X    The position of the best vulture 1.
     * @param Best_vulture2_X    The position of the best vulture 2.
     * @param random_vulture_X   The random vulture position array.
     * @param F                  The exploitation factor.
     * @param p2                 The probability threshold for phase 1 exploitation.
     * @param p3                 The probability threshold for phase 2 exploitation.
     * @param variables_no       The number of variables.
     * @return                   The updated current vulture position array.
     */
    public static double[] exploitation(double[] current_vulture_X, double[] Best_vulture1_X, double[] Best_vulture2_X,
                                        double[] random_vulture_X, double F, double p2, double p3, int variables_no) {
        Random rand = new Random();

        // Phase 1
        if (Math.abs(F) < 0.5) {
            if (rand.nextDouble() < p2) {
                // Calculate intermediate values A and B
                double[] A = new double[current_vulture_X.length];
                double[] B = new double[current_vulture_X.length];
                for (int i = 0; i < current_vulture_X.length; i++) {
                    A[i] = Best_vulture1_X[i] - ((Best_vulture1_X[i] * current_vulture_X[i]) / (Best_vulture1_X[i] - Math.pow(current_vulture_X[i], 2))) * F;
                    B[i] = Best_vulture2_X[i] - ((Best_vulture2_X[i] * current_vulture_X[i]) / (Best_vulture2_X[i] - Math.pow(current_vulture_X[i], 2))) * F;
                }
                // Update current vulture position by averaging A and B
                for (int i = 0; i < current_vulture_X.length; i++) {
                    current_vulture_X[i] = (A[i] + B[i]) / 2;
                }
            } else {
                // Update current vulture position using random vulture position, absolute difference, F, and levyFlight
                double[] levyFlight = levyFlight(variables_no); // Replace this line with your levyFlight implementation
                for (int i = 0; i < current_vulture_X.length; i++) {
                    current_vulture_X[i] = random_vulture_X[i] - Math.abs(random_vulture_X[i] - current_vulture_X[i]) * F * levyFlight[i];
                }
            }
        }

        // Phase 2
        if (Math.abs(F) >= 0.5) {
            if (rand.nextDouble() < p3) {
                // Update current vulture position using random vulture position, random values, and F
                for (int i = 0; i < current_vulture_X.length; i++) {
                    double randomValue = 2 * rand.nextDouble();
                    current_vulture_X[i] = Math.abs(randomValue * random_vulture_X[i] - current_vulture_X[i]) * (F + rand.nextDouble()) - (random_vulture_X[i] - current_vulture_X[i]);
                }
            } else {
                // Calculate intermediate values s1 and s2
                double[] s1 = new double[current_vulture_X.length];
                double[] s2 = new double[current_vulture_X.length];
                for (int i = 0; i < current_vulture_X.length; i++) {
                    s1[i] = random_vulture_X[i] * (rand.nextDouble() * current_vulture_X[i] / (2 * Math.PI)) * Math.cos(current_vulture_X[i]);
                    s2[i] = random_vulture_X[i] * (rand.nextDouble() * current_vulture_X[i] / (2 * Math.PI)) * Math.sin(current_vulture_X[i]);
                }
                // Update current vulture position by subtracting s1 and s2 from random vulture position
                for (int i = 0; i < current_vulture_X.length; i++) {
                    current_vulture_X[i] = random_vulture_X[i] - (s1[i] + s2[i]);
                }
            }
        }

        return current_vulture_X;
    }
}
